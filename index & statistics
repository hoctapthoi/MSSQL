-------- missing index tables -----------
SELECT DB_NAME(mid.database_id) AS DatabaseName,
       OBJECT_SCHEMA_NAME(mid.object_id, mid.database_id) AS SchemaName,
       OBJECT_NAME(mid.object_id, mid.database_id) AS ObjectName,
       migs.avg_user_impact,
       mid.equality_columns,
       mid.inequality_columns,
       mid.included_columns
FROM sys.dm_db_missing_index_groups mig
    INNER JOIN sys.dm_db_missing_index_group_stats migs
        ON migs.group_handle = mig.index_group_handle
    INNER JOIN sys.dm_db_missing_index_details mid
        ON mig.index_handle = mid.index_handle;

----------Unused index ------------
SELECT OBJECT_NAME(i.object_id) AS TableName,
       i.index_id,
       ISNULL(user_seeks, 0) AS UserSeeks,
       ISNULL(user_scans, 0) AS UserScans,
       ISNULL(user_lookups, 0) AS UserLookups,
       ISNULL(user_updates, 0) AS UserUpdates
FROM sys.indexes i
    LEFT OUTER JOIN sys.dm_db_index_usage_stats ius
        ON ius.object_id = i.object_id AND ius.index_id = i.index_id
WHERE OBJECTPROPERTY(i.object_id, 'IsMSShipped') = 0;

------------duplicate index--------------
SELECT OBJECT_SCHEMA_NAME(i.object_id) AS SchemaName,
       OBJECT_NAME(i.object_id) AS TableName,
       i.name,
       i.type_desc,
       STRING_AGG(c.name, ', ') WITHIN GROUP (ORDER BY key_ordinal) AS KeyCols

FROM sys.indexes i
    INNER JOIN sys.index_columns ic
        ON ic.object_id = i.object_id
           AND ic.index_id = i.index_id
    INNER JOIN sys.columns c
        ON c.object_id = i.object_id
           AND c.column_id = ic.column_id
WHERE OBJECTPROPERTYEX(i.object_id, 'IsMSShipped') = 0
      AND ic.is_included_column = 0
GROUP BY i.object_id,
         i.name,
         i.type_desc;

------------ index fragmentation--------
SELECT
    OBJECT_SCHEMA_NAME(i.object_id) AS SchemaName, 
    OBJECT_NAME(i.object_id) AS TableName, 
    i.name AS IndexName, 
    ips.partition_number, 
    ips.index_type_desc, 
    ips.index_level, 
    ips.avg_fragmentation_in_percent, 
    ips.page_count, 
    ips.avg_page_space_used_in_percent,
    'ALTER INDEX [' + i.name + '] ON [' + OBJECT_SCHEMA_NAME(i.object_id) + '].[' + OBJECT_NAME(i.object_id) + '] REBUILD WITH (ONLINE = ON);' AS RebuildCommand
FROM sys.indexes i
INNER JOIN sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'detailed') ips
    ON ips.object_id = i.object_id AND ips.index_id = i.index_id
WHERE ips.page_count > 1000 AND ips.avg_fragmentation_in_percent > 30;

--------------- Rebuild index------------
ALTER INDEX [ALL | <index name>] ON TableName REBUILD
WITH
PAD_INDEX = { ON | OFF }
FILLFACTOR = fillfactor
SORT_IN_TEMPDB = { ON | OFF }
ONLINE = {ON [ ( <low_priority_lock_wait> ) ] | OFF }
RESUMABLE = { ON | OFF }
MAX_DURATION = <time> [MINUTES}
MAXDOP = max_degree_of_parallelism
----------- Reorg index ------------------
ALTER INDEX [ALL | <index name>] ON TableName REORGANISE
WITH
LOB_COMPACTION = { ON | OFF }


---------- auto review index
---create table---

USE [AUD_DBLOG]
GO


CREATE TABLE [dbo].[idx](
	[date] [date] NULL,
	[DBName] [nvarchar](128) NULL,
	[SchemaName] [sysname] NOT NULL,
	[TableName] [sysname] NOT NULL,
	[IndexName] [sysname] NULL,
	[IndexKeys] [nvarchar](max) NULL,
	[IndexType] [nvarchar](60) NULL,
	[IndexSizeMB] [bigint] NULL,
	[idx_fragment] [float] NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO

------------ insert index into table ----

DECLARE @dbName NVARCHAR(MAX)
DECLARE @query NVARCHAR(MAX)

-- Tạo CURSOR để lặp qua tất cả các database trong hệ thống
DECLARE db_cursor CURSOR FOR
SELECT name 
FROM sys.databases
WHERE state_desc = 'ONLINE' -- Chỉ chọn những database đang hoạt động
  AND name NOT IN ('master', 'tempdb', 'model', 'msdb') -- Loại trừ các database hệ thống

OPEN db_cursor

FETCH NEXT FROM db_cursor INTO @dbName

WHILE @@FETCH_STATUS = 0
BEGIN
    -- Tạo câu truy vấn động cho từng database
    SET @query = 'insert into AUD_DBLOG.dbo.idx
    SELECT DISTINCT cast(getdate() as date) date,
        ''' + @dbName + ''' AS DBName,
        s.name AS SchemaName,
        t.name AS TableName,
        i.name AS IndexName,
        STUFF((
            SELECT '', '' + c.name
            FROM sys.index_columns ic
            INNER JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id
            WHERE ic.object_id = i.object_id AND ic.index_id = i.index_id
            ORDER BY ic.key_ordinal
            FOR XML PATH(''''), TYPE
        ).value(''.'', ''NVARCHAR(MAX)''), 1, 2, '''') AS IndexKeys,
        i.type_desc AS IndexType,
        ius.used_page_count * 8 / 1024 AS IndexSizeMB,
        stats.avg_fragmentation_in_percent AS idx_fragment
    FROM 
        ' + @dbName + '.sys.tables t
        INNER JOIN ' + @dbName + '.sys.schemas s ON t.schema_id = s.schema_id
        INNER JOIN ' + @dbName + '.sys.indexes i ON t.object_id = i.object_id
        INNER JOIN ' + @dbName + '.sys.dm_db_partition_stats ius ON i.object_id = ius.object_id AND i.index_id = ius.index_id
        LEFT JOIN ' + @dbName + '.sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, ''LIMITED'') AS stats
            ON i.object_id = stats.object_id AND i.index_id = stats.index_id
    WHERE 
        s.name NOT IN (''cdc'')
        AND i.type_desc <> ''HEAP''
        AND ius.used_page_count * 8 / 1024 > 8
    ORDER BY 
        s.name, t.name, i.name;
    '

    -- Thực thi câu truy vấn cho từng database
    EXEC sp_executesql @query

    FETCH NEXT FROM db_cursor INTO @dbName
END

CLOSE db_cursor
DEALLOCATE db_cursor

------ kiểm tra trạng thái database statistic ----------
SELECT 
    name AS [Database_Name],
    database_id,
    CASE is_auto_create_stats_on 
        WHEN 1 THEN 'ON' 
        ELSE 'OFF' 
    END AS [Auto_Create_Stats],
    CASE is_auto_update_stats_on 
        WHEN 1 THEN 'ON' 
        ELSE 'OFF' 
    END AS [Auto_Update_Stats],
    CASE is_auto_update_stats_async_on 
        WHEN 1 THEN 'ON' 
        ELSE 'OFF' 
    END AS [Auto_Update_Stats_Async],
    state_desc AS [State],
    recovery_model_desc AS [Recovery_Model]
FROM sys.databases
WHERE database_id > 4  -- Bỏ qua system databases
ORDER BY name;
